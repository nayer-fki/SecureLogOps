input {
  redis {
    host      => "redis"
    port      => 6379
    key       => "ingest:queue"
    data_type => "list"
    codec     => json
  }
}

filter {

  # -----------------------------
  # 0) marker
  # -----------------------------
  mutate { add_field => { "ingested_by" => "logstash_from_redis" } }

  # -----------------------------
  # 1) FORCE message from payload.*
  # -----------------------------
  if [payload][extra][message] and [payload][extra][message] != "" {
    mutate { replace => { "message" => "%{[payload][extra][message]}" } }
  } else if [payload][message] and [payload][message] != "" {
    mutate { replace => { "message" => "%{[payload][message]}" } }
  }

  # -----------------------------
  # 2) FORCE env / endpoint
  # -----------------------------
  if ![env] and [payload][env] { mutate { add_field => { "env" => "%{[payload][env]}" } } }
  if ![endpoint] and [payload][endpoint] { mutate { add_field => { "endpoint" => "%{[payload][endpoint]}" } } }

  # -----------------------------
  # 3) Timestamp safe
  # -----------------------------
  if [@timestamp] and [@timestamp] =~ "^\d{4}-\d{2}-\d{2}T" {
    date { match => ["@timestamp","ISO8601"] target => "@timestamp" tag_on_failure => ["_dateparsefailure"] }
  } else if [payload][@timestamp] {
    date { match => ["[payload][@timestamp]","ISO8601"] target => "@timestamp" tag_on_failure => ["_dateparsefailure"] }
  }

  # -----------------------------
  # 4) data_stream forced
  # -----------------------------
  mutate {
    replace => {
      "[data_stream][type]"      => "logs"
      "[data_stream][dataset]"   => "ingest"
      "[data_stream][namespace]" => "dev"
    }
  }

  # -----------------------------
  # 5) FIX source conflict: keep as log_source
  # -----------------------------
  if [source] and [source] != "" {
    mutate { add_field => { "log_source" => "%{source}" } }
    mutate { remove_field => ["source"] }
  } else if [payload][source] and [payload][source] != "" {
    mutate { add_field => { "log_source" => "%{[payload][source]}" } }
  }

  # -----------------------------
  # 6) Normalize host/service objects safely
  #    (avoid host/service as STRING)
  # -----------------------------
  ruby {
    code => '
      # host
      h = event.get("host")
      if h.is_a?(String)
        event.set("[host][name]", h) if event.get("[host][name]").nil?
        event.remove("host")
      end
      ph = event.get("[payload][host]")
      if event.get("host").nil? && ph.is_a?(Hash)
        event.set("host", ph)
      end

      # service
      s = event.get("service")
      if s.is_a?(String)
        event.set("[service][name]", s) if event.get("[service][name]").nil?
        event.remove("service")
      end
      ps = event.get("[payload][service]")
      if event.get("service").nil? && ps.is_a?(Hash)
        event.set("service", ps)
      end
    '
  }

  # extra host_name/service_name fallback
  if [payload][extra][host_name] and ![host][name] {
    mutate { add_field => { "[host][name]" => "%{[payload][extra][host_name]}" } }
  }
  if [payload][extra][service_name] and ![service][name] {
    mutate { add_field => { "[service][name]" => "%{[payload][extra][service_name]}" } }
  }

  # -----------------------------
  # 7) observer
  # -----------------------------
  if ![observer][name] { mutate { add_field => { "[observer][name]" => "ingest-service" } } }

  # -----------------------------
  # 8) event.original (store final message)
  # -----------------------------
  if [message] and ![event][original] {
    mutate { add_field => { "[event][original]" => "%{message}" } }
  }

  # -----------------------------
  # 9) syslog helpers
  # -----------------------------
  if ![syslog][msg] and [message] { mutate { add_field => { "[syslog][msg]" => "%{message}" } } }
  if ![syslog][raw] and [syslog][msg] { mutate { add_field => { "[syslog][raw]" => "%{[syslog][msg]}" } } }

  # -----------------------------
  # 10) cleanup (keep message!)
  # -----------------------------
  mutate {
    remove_field => [
      "payload",
      "@version",
      "tags"
    ]
  }
}

output {
  elasticsearch {
    hosts       => ["http://elasticsearch:9200"]
    user        => "elastic"
    password    => "ChangeMe_Elastic123!"
    data_stream => true
    action      => "create"
  }
  stdout { codec => rubydebug }
}
